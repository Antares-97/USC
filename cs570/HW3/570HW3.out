\BOOKMARK [1][-]{section.1}{Graded\040Problems}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{Design\040a\040data\040structure\040that\040has\040the\040following\040properties\040\(assume\040n\040elements\040in\040the\040data\040structure,\040and\040that\040the\040data\040structure\040properties\040need\040to\040be\040preserved\040at\040the\040end\040of\040each\040operation\):}{section.1}% 2
\BOOKMARK [3][-]{subsubsection.1.1.1}{Describe\040how\040your\040data\040structure\040will\040work}{subsection.1.1}% 3
\BOOKMARK [3][-]{subsubsection.1.1.2}{Give\040algorithms\040that\040implement\040the\040Extract-Median\(\)\040and\040Insert\(\)\040functions.}{subsection.1.1}% 4
\BOOKMARK [2][-]{subsection.1.2}{There\040is\040a\040stream\040of\040integers\040that\040comes\040continuously\040to\040a\040small\040server.\040The\040job\040of\040the\040server\040is\040to\040keep\040track\040of\040k\040largest\040numbers\040that\040it\040has\040seen\040so\040far.\040The\040server\040has\040the\040following\040restrictions:\040Design\040an\040algorithm\040on\040the\040server\040to\040perform\040its\040job\040with\040the\040requirements\040listed\040above.}{section.1}% 5
\BOOKMARK [2][-]{subsection.1.3}{When we have two sorted lists of numbers in non-descending order, and we need to merge them into one sorted list, we can simply compare the first two elements of the lists, extract the smaller one and attach it to the end of the new list, and repeat until one of the two original lists become empty, then we attach the remaining numbers to the end of the new list and it’s done. This takes linear time. Now, try to give an algorithm using O\(n logk\) time to merge k sorted lists \(you can also assume that they contain numbers in non-descending order\) into one sorted list, where n is the total number of elements in all the input lists. \(Hint: Use a min-heap for k-way merging.\)}{section.1}% 6
\BOOKMARK [2][-]{subsection.1.4}{Suppose\040you\040are\040given\040two\040sets\040A\040and\040B,\040each\040containing\040n\040positive\040integers.\040You\040can\040choose\040to\040reorder\040each\040set\040however\040you\040like.\040After\040reordering,\040let\040ai\040be\040the\040i-th\040element\040of\040set\040A,\040and\040let\040bi\040be\040the\040i-th\040element\040of\040set\040B.\040You\040then\040receive\040a\040payoff\040oni=1n\040aibi\040.\040Give\040an\040algorithm\040that\040will\040maximize\040your\040payoff.\040Prove\040that\040your\040algorithm\040maximizes\040the\040payoff,\040and\040state\040its\040running\040time.}{section.1}% 7
\BOOKMARK [1][-]{section.2}{Practice\040Problems}{}% 8
\BOOKMARK [2][-]{subsection.2.1}{The\040police\040department\040in\040a\040city\040has\040made\040all\040streets\040one-way.\040The\040mayor\040contends\040that\040there\040is\040still\040a\040way\040to\040drive\040legally\040from\040any\040intersection\040in\040the\040city\040to\040any\040other\040intersection,\040but\040the\040opposition\040is\040not\040convinced.\040A\040computer\040program\040is\040needed\040to\040determine\040whether\040the\040mayor\040is\040right.\040However,\040the\040city\040elections\040are\040coming\040up\040soon,\040and\040there\040is\040just\040enough\040a\040time\040to\040run\040a\040linear-time\040algorithm.}{section.2}% 9
\BOOKMARK [3][-]{subsubsection.2.1.1}{Formulate\040this\040as\040a\040graph\040problem\040and\040design\040a\040linear-time\040algorithm.\040Explain\040why\040it\040can\040be\040solved\040in\040linear\040time.}{subsection.2.1}% 10
\BOOKMARK [3][-]{subsubsection.2.1.2}{Suppose it now turns out that the mayors original claim is false. She next makes the following claim to supporters gathered in the Town Hall: ”If you start driving from the Town Hall \(located at an intersection\), navigating one-way streets, then no matter where you reach, there is always a way to drive legally back to the Town Hall.” Formulate this claim as a graph problem, and show how it can also be varied in linear time.}{subsection.2.1}% 11
\BOOKMARK [2][-]{subsection.2.2}{You\040are\040given\040a\040weighted\040directed\040graph\040G\040=\040\(V,\040E,\040w\)\040and\040the\040shortest\040path\040distances\040\(s,\040u\)\040from\040a\040source\040vertex\040s\040to\040every\040other\040vertex\040in\040G.\040However,\040you\040are\040not\040given\040\(u\)\040\(the\040predecessor\040pointers\).\040With\040this\040information,\040give\040an\040algorithm\040to\040find\040a\040shortest\040path\040from\040s\040to\040a\040given\040vertex\040t\040in\040O\(|V\040|+|E|\)}{section.2}% 12
