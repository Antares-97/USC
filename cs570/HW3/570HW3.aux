\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand*\HyPL@Entry[1]{}
\HyPL@Entry{0<</S/D>>}
\@writefile{toc}{\contentsline {section}{\numberline {1}Graded Problems}{1}{section.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Design a data structure that has the following properties (assume n elements in the data structure, and that the data structure properties need to be preserved at the end of each operation):}{1}{subsection.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.1}Describe how your data structure will work}{1}{subsubsection.1.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.2}Give algorithms that implement the Extract-Median() and Insert() functions.}{1}{subsubsection.1.1.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}There is a stream of integers that comes continuously to a small server. The job of the server is to keep track of k largest numbers that it has seen so far. The server has the following restrictions: Design an algorithm on the server to perform its job with the requirements listed above.}{2}{subsection.1.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}When we have two sorted lists of numbers in non-descending order, and we need to merge them into one sorted list, we can simply compare the first two elements of the lists, extract the smaller one and attach it to the end of the new list, and repeat until one of the two original lists become empty, then we attach the remaining numbers to the end of the new list and it’s done. This takes linear time. Now, try to give an algorithm using $O(n \qopname  \relax o{log}k)$ time to merge $k$ sorted lists (you can also assume that they contain numbers in non-descending order) into one sorted list, where $n$ is the total number of elements in all the input lists. (Hint: Use a min-heap for $k$-way merging.)}{2}{subsection.1.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.4}Suppose you are given two sets $A$ and $B$, each containing $n$ positive integers. You can choose to reorder each set however you like. After reordering, let $a_i$ be the $i$-th element of set $A$, and let $b_i$ be the $i$-th element of set $B$. You then receive a payoff on$\DOTSB \prod@ \slimits@ _{i=1}^n a_i^{b_i}$ . Give an algorithm that will maximize your payoff. Prove that your algorithm maximizes the payoff, and state its running time.}{2}{subsection.1.4}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces  Maximizing Payoff\relax }}{2}{algorithm.1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Practice Problems}{3}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}The police department in a city has made all streets one-way. The mayor contends that there is still a way to drive legally from any intersection in the city to any other intersection, but the opposition is not convinced. A computer program is needed to determine whether the mayor is right. However, the city elections are coming up soon, and there is just enough a time to run a linear-time algorithm.}{3}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.1}Formulate this as a graph problem and design a linear-time algorithm. Explain why it can be solved in linear time.}{3}{subsubsection.2.1.1}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {2}{\ignorespaces Determine a directed-graph is strongly-connected or not\relax }}{3}{algorithm.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.2}Suppose it now turns out that the mayors original claim is false. She next makes the following claim to supporters gathered in the Town Hall: ”If you start driving from the Town Hall (located at an intersection), navigating one-way streets, then no matter where you reach, there is always a way to drive legally back to the Town Hall.” Formulate this claim as a graph problem, and show how it can also be varied in linear time.}{4}{subsubsection.2.1.2}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {3}{\ignorespaces Determine starting from a given point you can go to somewhere and get back\relax }}{4}{algorithm.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}You are given a weighted directed graph $G = (V, E, w)$ and the shortest path distances $\delta (s, u)$ from a source vertex s to every other vertex in $G$. However, you are not given $\pi (u)$ (the predecessor pointers). With this information, give an algorithm to find a shortest path from $s$ to a given vertex $t$ in $O(|V |+|E|)$}{4}{subsection.2.2}}
